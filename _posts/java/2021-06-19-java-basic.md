---
title:  "[JAVA] 2. 자바 기본 프로그래밍"
date: 2021-06-19 21:29:00
categories:
  - JAVA 
tags:
  - JAVA 

---

# 1. 자바 프로그램의 구조

```java
public class HelloJava{

    public static int sum(int n, int m){  //메소드
        return n+m;
    }

    public static void main(String[] args){ //main메소드

    }
}
```
1. 클래스 만들기
자바 프로그램의 작성에서 가장 기본적이면서 중요한 것은 클래스를 만들고 그 안에 변수, 상수, 함수 등 모든 프로그램 요소를 작성한다. 클래스 바깥에는 어떤 것도 작성되면 안 된다.

2. main()메소드
자바 프로그램은 main()메소드에서부터 실행을 시작한다. main()메소드는 반드시 public, static, void 타입으로 선언되어야 한다. 한 클래스에 2개 이상의 main메소드를 작성하면 안 된다. 
자바 응용프로그램이 여러 클래스로 이루어지는 경우 실행을 시작할 클래스만 main()을 두면 된다. 모든 클래스가 main메소드를 가지지 않는다.

3. 메소드
클래스의 멤버 함수를 자바에서는 메소드라고 부른다. 메소드 개수에는 제한이 없다.

4. 변수
변수(variable)란 프로그램 실행 동안 데이터를 저장하는 공간으로 개발자가 이름을 붙이고 선언한다.

5. 문장
자바에서 모든 문장은 ';'로 끝나야 한다.

6. 주석문

```java
// 한 라인 주석. 행이 끝날 때까지 주석으로 처리

/*
여러 라인 주석
.
*/

```



# 2. 식별자
식별자(identifier)란 클래스, 변수, 상수, 메소드 등에 붙이는 이름을 말한다.

## 식별자 이름 규칙
* 특수문자(%, *, &, ^ 등), 공백(탭, space 등)은 식별자로 사용할수 없다.
* '_', '$'은 사용가능(첫번째 문자로도 사용가능하나 잘 사용하지 않음)
* 한글 사용가능
* if, while, class 등 자바 언어의 키워드는 식별자로 사용 불가
* 식별자의 첫 번째 문자로 숫자 사용불가
* 대소문자 구별
* 길이제한 없음

## 자바 키워드
자바 키워드란 자바에서 이미 그 용도가 정해진 것으로 예약어(reserved word)라고도 하며 식별자의 이름으로 사용할 수 없다.

abstract , assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, if, goto, implements, import, instanceof, int, interface, long, native, new, pacage, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
<br>
## 이름 붙이는 관습
1. 목적에 맞는 이름
2. 이름의 길이에 연연하지 말고 충분히 긴 이름
3. 이름을 붙이는 언어의 관습을 따르는 것이 좋다.
ex) AutoVendingMachine > autovendingmachine, auto_vending_machine

* 클래스 이름
클래스 이름은 첫번째 문자는 대문자로 시작하고 여러 단어가 복합되면 각 단어의 첫번째 문자만 대문자로 표시.
ex) public class HelloWorld {}, class AutoVendingMachine {}

* 변수, 메소드 이름
첫단어는 소문자로 표기하고 이후 각 단어의 첫번째 문자만 대문자로 표기.
ex) int myAge;  boolean isSingle;   public int getAge() { return 20;}

* 상수 이름
상수는 이름 전체를 대문자로 표기하도록 권장.
ex) final double PI = 3.141592;


<br><br>

# 3. 자바의 데이터 타입
데이터 타입 : 자바에서 다룰 수 있는 데이터의 종류.

![javaType](/img/java_type.PNG?raw=true)

* **기본 타입(8가지)** : boolean, char, byte, short, int, long, float, double
* **레퍼런스 타입(1가지)** : 레퍼런스 타입은 한가지이지만 용도는 3가지
배열에 대한 레퍼런스, 클래스에 대한 레퍼런스, 인터페이스에 대한 레퍼런스

 레퍼런스란 c/c++의 포인터와 비슷한 개념. 다만 실제로 주소 값을 가지지 않는다.

 자바에서 영어, 한글이든 모든 문자 하나는 2바이트의 유니코드로 저장된다.
 c/c++에서는 영어는 1바이트, 한글은 2바이트로 표현되어 한글과 영어가 섞여있는 문자열이나 파일을 다루는 프로그램 작성은 까다롭다.

 문자열은 자바의 기본 타입이 아니므로 String 클래스를 이용한다. 
<br>
 
 ## 리터럴(literal)
 
 리터럴이란 프로그램에 직접 표현한 값. 정수, 실수, 문자, 논리, 문자열 타입 모두 리터럴이 있다.
 ex) 34, 42.195, '%', true, "hello"

 **정수 리터럴**
 
 |유형|설명|사례|
 |--|----|----|
 |10진수|0으로 시작하지 않는 수|15 -> 10진수 15|
 |8진수|0으로 시작하는 수|015 -> 십진수 13 (1*8+5=13)|
 |16진수|0x로 시작하는 수|0x15 -> 십진수21(1*16+5=21)|
 |2진수|0b로 시작하는 수|0b0101 -> 십진수 5|

 **실수 리터럴**
 
 실수 리터럴은 소수점 형태나 지수 형태로 다음과 같이 실수를 표현한 값.
 ex) 12.     12.0    .1234    0.1234   1234E-4
 
 실수 리터럴은 double타입으로 자동 처리된다.
 숫자 뒤에 f나 F를 붙이면 float, d나 D를 붙이면 double 타입으로 강제 변환 가능.

 **문자 리터럴**
 
 문자 리터럴은 단일 인용부호로 문자를 표현하거나 \u 다음에 문자의 유니코드 값을 사용해 표현.
 ex) 'w',   'A',   '가',   \u0041(문자'A'의 유니코드 값(0041) 사용)

**특수문자 리터럴**

백슬래시 다음에 특수 기호를 붙여서 표현. 특수문자를 이스케이프 시퀀스라고도 한다.

|종류|의미|종류|의미|
|--|----|--|----|
|'\b'|백스페이스|'\r'|캐리지 리턴|
|'\t'|탭|'\\"'|이중 인용부호|
|'\n'|라인피드|'\\''|단일 인용부호|
|'\f'|폼피드|'\\\\'|백슬래시|

**논리 리터럴과 boolean 타입**

논리 리터럴은 true, false 두 개밖에 없음.

**null 리터럴**

null은 기본 타입에 사용될 수 없고 객체 레퍼런스에 대입된다.
```java
int n = null;      //오류. 기본타입에 null 값을 지정할 수 없음.
String str = null; //정상
```

**문자열 리터럴**

문자열 리터럴은 "Hello"와 같이 이중 인용부호로 표현.
<br>

## var 키워드
Java 10부터 지역 변수를 선언할 때 변수의 타입 대신 var 키워드를 사용할 수 있다.
```java
var price = 200;    // price는 int 타입으로 결정
var name = "kitae";
var pi = 3.14;
var point = new Point();
var v = new Vector<Integer>();

var name; //컴파일 오류.
```
변수 선언문에 초깃값이 주어지지 않으면 오류 발생. 또한 var의 사용은 지역변수에만 한정 된다. 
<br>
## 상수
상수를 만드는 방법은 변수 선언 시 final 키워드를 사용.
상수는 변수와 다르게 실행 중에 값 변경이 불가능.
ex) final double PI = 3.141592;
<br>
## 타입 변환
타입 변환이란 변수나 상수 혹은 리터럴의 타입을 다른 타입으로 바꾸는 것.
* **자동 타입 변환**
치환문이나 수식 내에서 타입이 일치하지 않을 때, 컴파일러는 오류 대신 작은 타입을 큰 타입으로 자동 변환한다.
```java
long m = 25;         //리터럴 25는 int타입. 25가 long 타입으로 자동 변환
double d = 3.14*10;  //실수 연산을 하기 위해 10이 10.0으로 자동변환
```
<br>

* **강제 타입 변환**
강제 타입 변환은 개발자가 강제로 타입 변환을 지시하는 경우.
```java
int n = 300;
byte b = n;  //컴파일 오류. int 타입은 byte 타입으로 자동 변환 안 됨.

byte b = (byte)n;  //n을 byte 타입으로 강제 변환. b=44

double d = 1.9;
int n = (int)d;  //강제 타입 변환으로 n은 1이됨
```
강제 변환을 하면 컴파일 오류가 발생하지 않지만 300에서 256을 초과한 만큼 즉 44(300%256=44)가 변수 b에 저장된다. 즉 데이터 손실이 발생한다.
실수를 정수로 강제 변환하면 소수점 이하의 손실이 발생한다.

강제 타입 변환을 캐스팅(casting)이라고도 부른다.
<br>

# 4. 자바에서 키 입력

## System.in

```java
int n = System.in.read() - '0';
```

System.in은 키보드 장치를 직접 제어하고 키 입력을 받는 표준 입력 스트림 객체이다.
System.in은 입력된 키를 단순한 바이트 정보로 응용프로그램에게 제공하므로 응용프로그램은 받은 바이트 정보를 문자나 숫자로 변환해야하는 번거로움이 있다.
-> 키보드에서 입력된 키를 문자나 정수, 실수, 문자열 등 사용자가 원하는 타입으로 변환해주는 Scanner 클래스를 사용하는 것이 효과적.

```java
import java.util.Scanner;

Scanner sc = new Scanner(System.in);

sc.close(); 
sc = new Scanner(System.in); //sc를 닫은 후 다시 sc로 키 입력을 받을 수 없음.
```

scanner 객체의 사용을 종료하려면 sc.close();를 해준다. scanner가 닫히면 System.in도 함께 닫히므로 더 이상 System.in을 사용해 키 입력을 받을 수 없다.

그래서 개발자는 응용프로그램 전체에 Scanner 객체를 하나만 생성하고 공유하는 것이 좋다. Scanner 객체를 여러개 생성해도 모두 하나뿐인 System.in을 공유하므로, 한 군데서 close()를 호출하면 System.in도 닫혀 응용프로그램 내 다른 Scanner 객체에서 키 입력을 받을 수 없다.

|메소드|설명|
|----|--------|
|String next()|다음 토큰을 문자열로 리턴|
|byte nextByte()|다음 토큰을 byte타입으로 리턴|
|short nextShort()|다음 토큰을 short타입으로 리턴|
|int nextInt()|다음 토큰을 int 타입으로 리턴|
|long nextLong()|다음 토큰을 long 타입으로 리턴|
|float nextFloat()|다음 토큰을 float타입으로 리턴|
|double nextDouble()|다음 토큰을 double타입으로 리턴|
|boolean nextBoolean()|다음 토큰을 boolean 타입으로 리턴|
|String nextLine()|\'n'을 포함하는 한 라인을 읽고 '\n'을 버린 나머지 문자열 리턴|
|void close()|Scanner의 사용 종료|
|boolean hasNext()|현재 입력된 토큰이 있으면 true, 아니면 입력 때까지 무한정 대기. 새로운 입력이 들어올 때 true리턴. ctrl-z 키가 입력되면 입력 끝이므로 false리턴|

"seoul welcome"와 같이 공백이 있는 문자열을 입력받기 위해서는 nextLine()을 사용.
또한 nextLine()은 <Enter>키의 입력을 기다리는 용도로도 사용가능. 빈문자열 ""을 리턴.
next()는 <Enter>키를 입력해도 문자열이나 숫자 등 다른 키가 입력될 때까지 기다린다. next()는 빈문자열 ""을 리턴하지 않는다.
<br>
<br>

# 5. 출력
```java
System.out.println("Hello");
System.out.print(3);
```
##형식화된 출력
값에 포맷을 명시해 원하는 형태로 출력하는 것.

출력 포맷의 형태 : %[argument_index$][flags][width][.precision]conversion

* argument_index$ : 매개변수를 위치적으로 지칭하는 정수. 항상 1부터 시작.

* flag : -(왼쪽 정렬) 같은 추가적인 출력 형식을 지정

* width : 출력될 자릿수의 폭

* .precision : 실수를 출력할 때 . 기호 다음에 소수점 이하 자릿수를 명시

* conversion : 하나의 문자로 이루어진 형식 지정 문자

|형식 지정자|설명|
|------|-----------|
|'b' or 'B'|출력하려는 값이 null이면 "false"출력/boolean이나 Boolean이면 값에따라 true/false출력/ 그외 true 출력|
|'h' or 'H'|출력하려는 값이 null이면 null출력/그외 해시코드 출력=Integer.toHexString(arg.hashCode())|
|'s' or 'S'|출력하려는 값이 null이면 null 출력 / Formattable 인터페이스를 구현했으면 arg.formatTo()결과 출력 / 그외 arg.toString() 결과 출력|
|'c' or 'C'|유니코드 문자|
|'d'|정수를 10진수로 출력|
|'o'|정수를 8진수로 출력|
|'x' or 'X'|정수를 16진수로 출력|
|'e' or 'E'|실수를 지수 형태로 출력|
|'f'|실수를 고정 소수점 형태로 출력|
|'g' or 'G'|실수를 정밀도에 따라 고정 소수점 또는 지수 형태로 출력|
|'a' or 'A'|실수의 밑수와 지수를 16진수로 표현|
|'%'|% 출력|
|'n'|'\n'과 같은 값을 출력|

|플래그|설명|
|---|------|
|-|왼쪽 정렬|
|#|형식 지정자에 따라 다른 형식으로 출력이 가능하면 다른 형식으로 출력. o인 경우에는 앞에 0이 출력. x또는 X인 경우에는 앞에 0x or 0X가 출력|
|+|항상 부호를 표시|
|' '|시작 빈 공간을 공백으로 채움|
|0|시작 빈 공간을 0으로 채움|
|,|1,000,000과 같이 세자리마다 ,를 포함한 수를 출력|
|(|음수인 경우 ( 와 ) 사이에 절대값을 출력|

<br>
<br>
# 6. 연산
##연산자
* 증감 : ++,  --
* 산술 : +, -, *, /, %
* 시프트 : >>, <<, >>>
* 비교 : >, <, >=, <=, ==, !=
* 비트 : &, |, ^, ~
* 논리 : &&, ||, !, ^
* 조건식 : ? :
* 대입 : =, *=, /=, +=, -=, &=, ^=, |=, <<=, >>=, >>>=
  
![jdk](/img/java_operation.PNG?raw=true)

## 비트연산
비트연산은 비트끼리 AND, OR, XOR, NOT 연산을 하는 비트 논리 연산과 비트를 오른쪽이나 왼쪽으로 이동시키는 비트 시프트 연산이 있다.

#### 비트개념
컴퓨터의 모든 정보는 0과 1 값만 가지는 2진수로 다루어지고 저장된다. 2진수의 한 자리를 비트라고 부르며 8개의 비트를 바이트라고 한다. 십진수 10을 한 바이트로 표현하면 00001010이다.

#### 비트 논리 연산
비트 논리 연산은 피연산자와 각 비트들끼리 이루어지는 AND, OR, XOR, NOT의 논리 연산으로 총 4개가 있다.
1. a & b : AND 연산 : 두 비트 모두 1이면 1, 그렇지 않으면 0
2. a | b : OR  연산 : 두 비트 모두 0이면 0, 그렇지 않으면 1
3. a ^ b : XOR 연산 : 두 비트가 다르면 1, 같으면 0
4. ~a    : NOT 연산 : 1을 0으로, 0을 1로 변환

#### 비트 시프트 연산
3개의 연산자를 이용해 새로운 비트를 오른쪽이나 왼쪽 끝에 삽입하면서 비트의 자리를 이동시키는 연산이다. 저장공간의 크기가 정해져 있으므로 시프트되는 방향에 따라 끝에 있는 비트는 사라지게 된다.

시프트 연산의 피연산자는 byte, short, int, long, char 타입만 가능.
1. a >> b : a의 각 비트를 오른쪽으로 b번 시프트. 최상위 비트의 빈자리는 시프트 전의 최상위 비트로 다시 채운다. 산술적 오른쪽 시프트라고 한다.
2. a >>> b : a의 각 비트를 오른쪽으로 b번 시프트. 최상위 비트의 빈자리는 항상 0으로 채운다. 논리적 오른쪽 시프트라고 한다.
3. a << b : a의 각 비트를 왼쪽으로 b번 시프트. 최하위 비트의 빈자리는 항상 0으로 채운다. 술적 왼쪽 시프트라고 한다.
